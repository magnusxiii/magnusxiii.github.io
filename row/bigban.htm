<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra Realistic Stellar Objects - Î¥Ï€ÎµÏ-Î¡ÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÎ¬ Î‘ÏƒÏ„ÏÎ¹ÎºÎ¬ Î£ÏÎ¼Î±Ï„Î±</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: radial-gradient(circle at center, #000814 0%, #000000 100%);
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #controls {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 30, 60, 0.95), rgba(0, 15, 40, 0.9));
            padding: 25px;
            border-radius: 20px;
            border: 3px solid rgba(0, 255, 255, 0.6);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(0, 100, 200, 0.1);
            backdrop-filter: blur(15px);
            max-height: 85vh;
            overflow-y: auto;
        }
        
        .control-group {
            margin-bottom: 18px;
        }
        
        .control-title {
            color: #00ffff;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 8px #00ffff;
            font-size: 14px;
        }
        
        label {
            display: block;
            margin-bottom: 6px;
            font-size: 12px;
            color: #e0e0e0;
        }
        
        input[type="range"] {
            width: 180px;
            margin-bottom: 6px;
            accent-color: #00ffff;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        
        .value-display {
            color: #ffff00;
            font-weight: bold;
            text-shadow: 0 0 5px #ffff00;
            font-size: 11px;
        }
        
        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 18px;
            margin: 4px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        .danger-btn {
            background: linear-gradient(45deg, #ff4444, #cc0000);
        }
        
        .special-btn {
            background: linear-gradient(45deg, #ff6600, #ff3300);
        }
        
        .cosmic-btn {
            background: linear-gradient(45deg, #9966ff, #6633cc);
        }
        
        #info {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: linear-gradient(135deg, rgba(30, 0, 60, 0.95), rgba(15, 0, 40, 0.9));
            padding: 20px;
            border-radius: 15px;
            font-size: 12px;
            max-width: 380px;
            border: 2px solid rgba(255, 0, 255, 0.6);
            box-shadow: 0 0 25px rgba(255, 0, 255, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .stellar-info {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(135deg, rgba(40, 20, 0, 0.95), rgba(30, 15, 0, 0.9));
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 0, 0.6);
            max-width: 280px;
            font-size: 11px;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .performance-info {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            font-size: 10px;
            border: 1px solid #666;
        }
        
        @media (max-width: 768px) {
            #controls {
                font-size: 10px;
                padding: 18px;
                max-height: 70vh;
            }
            
            input[type="range"] {
                width: 150px;
            }
            
            button {
                padding: 10px 14px;
                font-size: 10px;
            }
            
            .stellar-info {
                right: 10px;
                top: 10px;
                max-width: 220px;
                font-size: 10px;
            }
        }
        
        @media (max-width: 480px) {
            #controls {
                font-size: 9px;
                padding: 15px;
                max-height: 60vh;
            }
            
            input[type="range"] {
                width: 130px;
            }
            
            #info {
                font-size: 10px;
                max-width: 280px;
            }
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 20px;
            text-shadow: 0 0 15px #00ffff;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .quality-indicator {
            position: absolute;
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 5px;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="loading" id="loading">Î¦ÏŒÏÏ„Ï‰ÏƒÎ· Î¥Ï€ÎµÏ-Î¡ÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÎ¿Ï Î£ÏÎ¼Ï€Î±Î½Ï„Î¿Ï‚...</div>
        
        <div id="controls" style="display: none;">
            <div class="control-title">ğŸŒŸ Î ÏÎ¿Î·Î³Î¼Î­Î½Î¿Ï‚ ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î‘ÏƒÏ„ÏÎ¹ÎºÏÎ½ Î£Ï‰Î¼Î¬Ï„Ï‰Î½</div>
            
            <div class="control-group">
                <label>Î¤Î±Ï‡ÏÏ„Î·Ï„Î± Î§ÏÏŒÎ½Î¿Ï…:</label>
                <input type="range" id="timeSpeed" min="0.1" max="8" step="0.1" value="1">
                <span class="value-display" id="timeValue">1.0x</span>
            </div>
            
            <div class="control-group">
                <label>ÎˆÎ½Ï„Î±ÏƒÎ· Î’Î±ÏÏ…Ï„Î¹ÎºÎ¿Ï Î ÎµÎ´Î¯Î¿Ï…:</label>
                <input type="range" id="gravityField" min="0" max="5" step="0.1" value="1">
                <span class="value-display" id="gravityValue">1.0</span>
            </div>
            
            <div class="control-group">
                <label>Î‘ÎºÏ„Î¹Î½Î¿Î²Î¿Î»Î¯Î± Î‘ÏƒÏ„Î­ÏÏ‰Î½:</label>
                <input type="range" id="stellarRadiation" min="0.1" max="5" step="0.1" value="2">
                <span class="value-display" id="radiationValue">2.0</span>
            </div>
            
            <div class="control-group">
                <label>Î Î¿Î¹ÏŒÏ„Î·Ï„Î± Î•Ï†Î­:</label>
                <input type="range" id="effectsQuality" min="1" max="5" step="1" value="3">
                <span class="value-display" id="qualityValue">ÎœÎ­Ï„ÏÎ¹Î±</span>
            </div>
            
            <div class="control-group">
                <label>ÎˆÎ½Ï„Î±ÏƒÎ· Î£Ï‰Î¼Î±Ï„Î¹Î´Î¯Ï‰Î½:</label>
                <input type="range" id="particleDensity" min="0.1" max="3" step="0.1" value="1.5">
                <span class="value-display" id="particleValue">1.5</span>
            </div>
            
            <div class="control-group">
                <label>Î˜ÎµÏÎ¼Î¹ÎºÎ® Î‘ÎºÏ„Î¹Î½Î¿Î²Î¿Î»Î¯Î±:</label>
                <input type="range" id="thermalRadiation" min="0" max="3" step="0.1" value="1.2">
                <span class="value-display" id="thermalValue">1.2</span>
            </div>
            
            <div class="control-group">
                <button onclick="toggleAnimation()">â¸ï¸ Î Î±ÏÏƒÎ·/Î£Ï…Î½Î­Ï‡ÎµÎ¹Î±</button>
                <button onclick="resetView()">ğŸ”„ Î•Ï€Î±Î½Î±Ï†Î¿ÏÎ¬</button>
                <button onclick="toggleFullscreen()">ğŸ–¥ï¸ Î Î»Î®ÏÎ·Ï‚ ÎŸÎ¸ÏŒÎ½Î·</button>
            </div>
            
            <div class="control-group">
                <button onclick="focusRedGiant()">ğŸ”´ ÎšÏŒÎºÎºÎ¹Î½Î¿Ï‚ Î“Î¯Î³Î±Î½Ï„Î±Ï‚</button>
                <button onclick="focusBlueGiant()">ğŸ”µ ÎœÏ€Î»Îµ Î“Î¯Î³Î±Î½Ï„Î±Ï‚</button>
                <button onclick="focusWhiteDwarf()">âšª Î›ÎµÏ…ÎºÏŒÏ‚ ÎÎ¬Î½Î¿Ï‚</button>
            </div>
            
            <div class="control-group">
                <button class="danger-btn" onclick="focusBlackHole()">âš« ÎœÎ±ÏÏÎ· Î¤ÏÏÏ€Î±</button>
                <button class="special-btn" onclick="createSupernova()">ğŸ’¥ Supernova</button>
                <button class="cosmic-btn" onclick="createGammaRayBurst()">âš¡ Gamma Ray Burst</button>
            </div>
            
            <div class="control-group">
                <button onclick="toggleAccretionDisk()">ğŸŒ€ Î”Î¯ÏƒÎºÎ¿Ï‚ Î ÏÎ¿ÏƒÎ±ÏÎ¾Î·ÏƒÎ·Ï‚</button>
                <button onclick="toggleStellarWinds()">ğŸ’¨ Î‘ÏƒÏ„ÏÎ¹ÎºÎ¿Î¯ Î†Î½ÎµÎ¼Î¿Î¹</button>
                <button onclick="toggleMagneticFields()">ğŸ§² ÎœÎ±Î³Î½Î·Ï„Î¹ÎºÎ¬ Î ÎµÎ´Î¯Î±</button>
            </div>
            
            <div class="control-group">
                <button onclick="toggleRelativisticEffects()">âš¡ Î£Ï‡ÎµÏ„Î¹ÎºÎ¹ÏƒÏ„Î¹ÎºÎ¬ Î•Ï†Î­</button>
                <button onclick="toggleQuantumEffects()">ğŸ”¬ ÎšÎ²Î±Î½Ï„Î¹ÎºÎ¬ Î•Ï†Î­</button>
                <button onclick="toggleAdvancedPhysics()">ğŸ”¬ Î ÏÎ¿Î·Î³Î¼Î­Î½Î· Î¦Ï…ÏƒÎ¹ÎºÎ®</button>
            </div>
        </div>
        
        <div class="stellar-info" id="stellarInfo" style="display: none;">
            <h3 id="objectName">Î‘ÏƒÏ„ÏÎ¹ÎºÏŒ Î£ÏÎ¼Î±</h3>
            <p><strong>Î¤ÏÏ€Î¿Ï‚:</strong> <span id="objectType">-</span></p>
            <p><strong>ÎœÎ¬Î¶Î±:</strong> <span id="objectMass">-</span></p>
            <p><strong>Î˜ÎµÏÎ¼Î¿ÎºÏÎ±ÏƒÎ¯Î±:</strong> <span id="objectTemp">-</span></p>
            <p><strong>Î—Î»Î¹ÎºÎ¯Î±:</strong> <span id="objectAge">-</span></p>
            <p><strong>Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ·:</strong> <span id="objectDistance">-</span></p>
            <p><strong>Î¦Ï‰Ï„ÎµÎ¹Î½ÏŒÏ„Î·Ï„Î±:</strong> <span id="objectLuminosity">-</span></p>
            <p><strong>ÎœÎµÏ„Î±Î»Î»Î¹ÎºÏŒÏ„Î·Ï„Î±:</strong> <span id="objectMetallicity">-</span></p>
        </div>
        
        <div class="performance-info" id="performanceInfo" style="display: none;">
            <p>FPS: <span id="fpsCounter">60</span></p>
            <p>Î£Ï‰Î¼Î±Ï„Î¯Î´Î¹Î±: <span id="particleCount">0</span></p>
            <p>Draw Calls: <span id="drawCalls">0</span></p>
        </div>
        
        <div class="quality-indicator" id="qualityIndicator">
            <div>Î Î¿Î¹ÏŒÏ„Î·Ï„Î±: <span id="currentQuality">ÎœÎ­Ï„ÏÎ¹Î±</span></div>
        </div>
        
        <div id="info" style="display: none;">
            <h3>ğŸŒŒ Î¥Ï€ÎµÏ-Î¡ÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÎ® Î ÏÎ¿ÏƒÎ¿Î¼Î¿Î¯Ï‰ÏƒÎ· Î‘ÏƒÏ„ÏÎ¹ÎºÏÎ½ Î£Ï‰Î¼Î¬Ï„Ï‰Î½</h3>
            <p><strong>ÎÎ­Î± Î§Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬:</strong></p>
            <p>â€¢ Î ÏÎ¿Î·Î³Î¼Î­Î½Î± particle systems Î¼Îµ Ï†Ï…ÏƒÎ¹ÎºÎ® Ï€ÏÎ¿ÏƒÎ¿Î¼Î¿Î¯Ï‰ÏƒÎ·</p>
            <p>â€¢ Î¡ÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÎ¬ Î¸ÎµÏÎ¼Î¹ÎºÎ¬ ÎµÏ†Î­ ÎºÎ±Î¹ Î±ÎºÏ„Î¹Î½Î¿Î²Î¿Î»Î¯Î±</p>
            <p>â€¢ Î£Ï‡ÎµÏ„Î¹ÎºÎ¹ÏƒÏ„Î¹ÎºÎ¬ ÎµÏ†Î­ ÎºÎ¿Î½Ï„Î¬ ÏƒÏ„Î· Î¼Î±ÏÏÎ· Ï„ÏÏÏ€Î±</p>
            <p>â€¢ Î‘ÏƒÏ„ÏÎ¹ÎºÎ¿Î¯ Î¬Î½ÎµÎ¼Î¿Î¹ ÎºÎ±Î¹ Î¼Î±Î³Î½Î·Ï„Î¹ÎºÎ¬ Ï€ÎµÎ´Î¯Î±</p>
            <p>â€¢ Gamma ray bursts ÎºÎ±Î¹ ÎºÎ²Î±Î½Ï„Î¹ÎºÎ¬ ÎµÏ†Î­</p>
            <p><strong>Î§ÎµÎ¹ÏÎ¹ÏƒÎ¼ÏŒÏ‚:</strong> ÎšÎ»Î¹Îº ÎºÎ±Î¹ ÏƒÏÏÏƒÎ¹Î¼Î¿ Î³Î¹Î± Ï€ÎµÏÎ¹ÏƒÏ„ÏÎ¿Ï†Î®, scroll Î³Î¹Î± zoom</p>
        </div>
    </div>

    <script>
        // Î Î±Î³ÎºÏŒÏƒÎ¼Î¹ÎµÏ‚ Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚
        let scene, camera, renderer, composer;
        let redGiant, blueGiant, whiteDwarf, blackHole;
        let accretionDisk, eventHorizon;
        let particleSystems = [];
        let stellarWinds = [];
        let magneticFieldLines = [];
        let animationId;
        let isAnimating = true;
        let showAccretionDisk = true;
        let showStellarWinds = true;
        let showMagneticFields = true;
        let showRelativisticEffects = false;
        let showQuantumEffects = false;
        let advancedPhysics = false;
        let currentFocus = null;
        
        // Î Î±ÏÎ¬Î¼ÎµÏ„ÏÎ¿Î¹ Ï€ÏÎ¿ÏƒÎ¿Î¼Î¿Î¯Ï‰ÏƒÎ·Ï‚
        let timeSpeed = 1.0;
        let gravityFieldStrength = 1.0;
        let stellarRadiationLevel = 2.0;
        let effectsQuality = 3;
        let particleDensity = 1.5;
        let thermalRadiation = 1.2;
        
        // Performance monitoring
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 60;
        
        // ÎœÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚ ÎµÎ»Î­Î³Ï‡Î¿Ï… ÎºÎ¬Î¼ÎµÏÎ±Ï‚
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;
        let cameraDistance = 80;
        let cameraAngleX = 0;
        let cameraAngleY = 0;
        let cameraTarget = new THREE.Vector3(0, 0, 0);
        
        // Î‘ÏƒÏ„ÏÎ¹ÎºÎ¬ Î´ÎµÎ´Î¿Î¼Î­Î½Î± Î¼Îµ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎµÏ‚ Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚
        const stellarData = {
            redGiant: {
                name: "Betelgeuse (ÎšÏŒÎºÎºÎ¹Î½Î¿Ï‚ Î¥Ï€ÎµÏÎ³Î¯Î³Î±Î½Ï„Î±Ï‚)",
                type: "M1-2 Ia-ab",
                mass: "16.5-19 Î·Î»Î¹Î±ÎºÎ­Ï‚ Î¼Î¬Î¶ÎµÏ‚",
                temp: "3,590 K",
                age: "8-8.5 ÎµÎºÎ±Ï„. Î­Ï„Î·",
                distance: "548 Î­Ï„Î· Ï†Ï‰Ï„ÏŒÏ‚",
                luminosity: "126,000 Lâ˜‰",
                metallicity: "[Fe/H] = -0.05"
            },
            blueGiant: {
                name: "Rigel (ÎœÏ€Î»Îµ Î¥Ï€ÎµÏÎ³Î¯Î³Î±Î½Ï„Î±Ï‚)",
                type: "B8 Ia",
                mass: "21 Î·Î»Î¹Î±ÎºÎ­Ï‚ Î¼Î¬Î¶ÎµÏ‚",
                temp: "12,100 K",
                age: "8 ÎµÎºÎ±Ï„. Î­Ï„Î·",
                distance: "860 Î­Ï„Î· Ï†Ï‰Ï„ÏŒÏ‚",
                luminosity: "120,000 Lâ˜‰",
                metallicity: "[Fe/H] = -0.06"
            },
            whiteDwarf: {
                name: "Sirius B (Î›ÎµÏ…ÎºÏŒÏ‚ ÎÎ¬Î½Î¿Ï‚)",
                type: "DA2",
                mass: "0.978 Î·Î»Î¹Î±ÎºÎ­Ï‚ Î¼Î¬Î¶ÎµÏ‚",
                temp: "25,200 K",
                age: "228 ÎµÎºÎ±Ï„. Î­Ï„Î·",
                distance: "8.6 Î­Ï„Î· Ï†Ï‰Ï„ÏŒÏ‚",
                luminosity: "0.026 Lâ˜‰",
                metallicity: "[Fe/H] = 0.5"
            },
            blackHole: {
                name: "Cygnus X-1",
                type: "Stellar Black Hole",
                mass: "21.2 Î·Î»Î¹Î±ÎºÎ­Ï‚ Î¼Î¬Î¶ÎµÏ‚",
                temp: "6.2 Ã— 10^-8 K (Hawking)",
                age: "Î‘Î¹ÏÎ½Î¹Î±",
                distance: "7,200 Î­Ï„Î· Ï†Ï‰Ï„ÏŒÏ‚",
                luminosity: "2.6 Ã— 10^39 erg/s (X-ray)",
                metallicity: "N/A"
            }
        };
        
        function init() {
            // Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± ÏƒÎºÎ·Î½Î®Ï‚
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000002);
            scene.fog = new THREE.FogExp2(0x000011, 0.0008);
            
            // Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± ÎºÎ¬Î¼ÎµÏÎ±Ï‚
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
            camera.position.set(0, 20, cameraDistance);
            
            // Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± renderer Î¼Îµ Ï€ÏÎ¿Î·Î³Î¼Î­Î½ÎµÏ‚ ÏÏ…Î¸Î¼Î¯ÏƒÎµÎ¹Ï‚
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance",
                precision: "highp"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.5;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.physicallyCorrectLights = true;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Ï€ÏÎ¿Î·Î³Î¼Î­Î½Î¿Ï… Ï†Ï‰Ï„Î¹ÏƒÎ¼Î¿Ï
            createAdvancedLighting();
            
            // Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Ï…Ï€ÎµÏ-ÏÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÎ¿Ï Î±ÏƒÏ„ÎµÏÎ¹Î¿Ï Ï†ÏŒÎ½Ï„Î¿Ï…
            createUltraRealisticStarField();
            
            // Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Î±ÏƒÏ„ÏÎ¹ÎºÏÎ½ ÏƒÏ‰Î¼Î¬Ï„Ï‰Î½ Î¼Îµ Ï€ÏÎ¿Î·Î³Î¼Î­Î½Î± ÎµÏ†Î­
            createUltraRealisticRedGiant();
            createUltraRealisticBlueGiant();
            createUltraRealisticWhiteDwarf();
            createUltraRealisticBlackHole();
            
            // Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Ï€ÏÎ¿Î·Î³Î¼Î­Î½Ï‰Î½ ÏƒÏ…ÏƒÏ„Î·Î¼Î¬Ï„Ï‰Î½
            createAdvancedAccretionDisk();
            createStellarWindSystems();
            createMagneticFieldSystems();
            createAdvancedNebulae();
            
            // Event listeners
            setupEventListeners();
            
            // Î‘Ï€ÏŒÎºÏÏ…ÏˆÎ· loading ÎºÎ±Î¹ ÎµÎ¼Ï†Î¬Î½Î¹ÏƒÎ· UI
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('controls').style.display = 'block';
                document.getElementById('info').style.display = 'block';
                document.getElementById('stellarInfo').style.display = 'block';
                document.getElementById('performanceInfo').style.display = 'block';
                updateStellarInfo('redGiant');
            }, 3000);
            
            // ÎˆÎ½Î±ÏÎ¾Î· animation loop
            animate();
        }
        
        function createAdvancedLighting() {
            // Ambient light Î¼Îµ Ï‡ÏÏ‰Î¼Î±Ï„Î¹ÎºÎ® Î¸ÎµÏÎ¼Î¿ÎºÏÎ±ÏƒÎ¯Î±
            const ambientLight = new THREE.AmbientLight(0x0a0a2a, 0.15);
            scene.add(ambientLight);
            
            // Hemisphere light Î³Î¹Î± ÏÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÏŒ Ï†Ï‰Ï„Î¹ÏƒÎ¼ÏŒ
            const hemisphereLight = new THREE.HemisphereLight(0x4444bb, 0x002244, 0.3);
            scene.add(hemisphereLight);
            
            // Directional light Ï€Î¿Ï… Ï€ÏÎ¿ÏƒÎ¿Î¼Î¿Î¹ÏÎ½ÎµÎ¹ Ï„Î¿ Ï†Ï‰Ï‚ Î±Ï€ÏŒ Ï„Î¿ ÎºÎ­Î½Ï„ÏÎ¿ Ï„Î¿Ï… Î³Î±Î»Î±Î¾Î¯Î±
            const directionalLight = new THREE.DirectionalLight(0x9999ff, 0.4);
            directionalLight.position.set(100, 100, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 1000;
            directionalLight.shadow.camera.left = -200;
            directionalLight.shadow.camera.right = 200;
            directionalLight.shadow.camera.top = 200;
            directionalLight.shadow.camera.bottom = -200;
            scene.add(directionalLight);
        }
        
        function createUltraRealisticStarField() {
            // ÎšÏÏÎ¹Î¿ Î±ÏƒÏ„ÎµÏÏŒÏ€Î»Î¿Î¹Î¿ Î¼Îµ Ï€Î¿Î»Î»Î±Ï€Î»Î¬ ÎµÏ€Î¯Ï€ÎµÎ´Î±
            const layers = [
                { count: 5000, distance: 1000, size: [0.5, 3], brightness: [0.3, 1] },
                { count: 3000, distance: 1500, size: [0.3, 2], brightness: [0.2, 0.8] },
                { count: 2000, distance: 2000, size: [0.2, 1.5], brightness: [0.1, 0.6] }
            ];
            
            layers.forEach((layer, layerIndex) => {
                const starGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(layer.count * 3);
                const colors = new Float32Array(layer.count * 3);
                const sizes = new Float32Array(layer.count);
                const phases = new Float32Array(layer.count);
                
                for (let i = 0; i < layer.count; i++) {
                    // Î˜Î­ÏƒÎµÎ¹Ï‚ Î¼Îµ ÏƒÏ†Î±Î¹ÏÎ¹ÎºÎ® ÎºÎ±Ï„Î±Î½Î¿Î¼Î®
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const radius = layer.distance + (Math.random() - 0.5) * 200;
                    
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                    
                    // Î¡ÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÎ¬ Ï‡ÏÏÎ¼Î±Ï„Î± Î±ÏƒÏ„Î­ÏÏ‰Î½ Î²Î¬ÏƒÎµÎ¹ Î¸ÎµÏÎ¼Î¿ÎºÏÎ±ÏƒÎ¯Î±Ï‚
                    const temp = Math.random();
                    let r, g, b;
                    
                    if (temp < 0.05) {
                        // O-type (Î¼Ï€Î»Îµ)
                        r = 0.6; g = 0.7; b = 1.0;
                    } else if (temp < 0.15) {
                        // B-type (Î¼Ï€Î»Îµ-Î»ÎµÏ…ÎºÏŒ)
                        r = 0.7; g = 0.8; b = 1.0;
                    } else if (temp < 0.30) {
                        // A-type (Î»ÎµÏ…ÎºÏŒ)
                        r = 1.0; g = 1.0; b = 1.0;
                    } else if (temp < 0.50) {
                        // F-type (ÎºÎ¯Ï„ÏÎ¹Î½Î¿-Î»ÎµÏ…ÎºÏŒ)
                        r = 1.0; g = 1.0; b = 0.8;
                    } else if (temp < 0.70) {
                        // G-type (ÎºÎ¯Ï„ÏÎ¹Î½Î¿)
                        r = 1.0; g = 0.9; b = 0.7;
                    } else if (temp < 0.85) {
                        // K-type (Ï€Î¿ÏÏ„Î¿ÎºÎ±Î»Î¯)
                        r = 1.0; g = 0.7; b = 0.4;
                    } else {
                        // M-type (ÎºÏŒÎºÎºÎ¹Î½Î¿)
                        r = 1.0; g = 0.4; b = 0.2;
                    }
                    
                    colors[i * 3] = r;
                    colors[i * 3 + 1] = g;
                    colors[i * 3 + 2] = b;
                    
                    sizes[i] = layer.size[0] + Math.random() * (layer.size[1] - layer.size[0]);
                    phases[i] = Math.random() * Math.PI * 2;
                }
                
                starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                starGeometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
                
                const starMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        pixelRatio: { value: renderer.getPixelRatio() }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 color;
                        attribute float phase;
                        varying vec3 vColor;
                        varying float vAlpha;
                        uniform float time;
                        uniform float pixelRatio;
                        
                        void main() {
                            vColor = color;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            
                            // Î¡ÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÏŒ twinkling
                            float twinkle = sin(time * 2.0 + phase) * 0.3 + 0.7;
                            float atmospheric = sin(time * 0.5 + phase * 2.0) * 0.1 + 0.9;
                            
                            vAlpha = twinkle * atmospheric;
                            
                            float finalSize = size * pixelRatio * (400.0 / -mvPosition.z) * twinkle;
                            gl_PointSize = max(finalSize, 1.0);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        varying float vAlpha;
                        
                        void main() {
                            float r = distance(gl_PointCoord, vec2(0.5));
                            if (r > 0.5) discard;
                            
                            // Î¡ÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÏŒ diffraction pattern
                            float intensity = 1.0 - smoothstep(0.0, 0.5, r);
                            intensity = pow(intensity, 0.8);
                            
                            // Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ· diffraction spikes Î³Î¹Î± Ï†Ï‰Ï„ÎµÎ¹Î½Î¬ Î±ÏƒÏ„Î­ÏÎ¹Î±
                            vec2 coord = gl_PointCoord - 0.5;
                            float spike = max(
                                exp(-abs(coord.x) * 20.0),
                                exp(-abs(coord.y) * 20.0)
                            ) * 0.3;
                            
                            intensity += spike;
                            
                            gl_FragColor = vec4(vColor, intensity * vAlpha);
                        }
                    `,
                    transparent: true,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending
                });
                
                const stars = new THREE.Points(starGeometry, starMaterial);
                scene.add(stars);
            });
        }
        
        function createUltraRealisticRedGiant() {
            const redGiantGroup = new THREE.Group();
            
            // ÎšÏÏÎ¹Î¿ ÏƒÏÎ¼Î± Î¼Îµ Ï€ÏÎ¿Î·Î³Î¼Î­Î½Î¿ shader
            const geometry = new THREE.SphereGeometry(8, 64, 64);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    temperature: { value: 3590 },
                    turbulence: { value: 0.5 },
                    radiationLevel: { value: stellarRadiationLevel }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec2 vUv;
                    uniform float time;
                    uniform float turbulence;
                    
                    // Simplex noise function
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                    
                    float snoise(vec3 v) {
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                        vec3 i = floor(v + dot(v, C.yyy));
                        vec3 x0 = v - i + dot(i, C.xxx);
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min(g.xyz, l.zxy);
                        vec3 i2 = max(g.xyz, l.zxy);
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;
                        i = mod289(i);
                        vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                        float n_ = 0.142857142857;
                        vec3 ns = n_ * D.wyz - D.xzx;
                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_);
                        vec4 x = x_ *ns.x + ns.yyyy;
                        vec4 y = y_ *ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);
                        vec4 b0 = vec4(x.xy, y.xy);
                        vec4 b1 = vec4(x.zw, y.zw);
                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));
                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                        vec3 p0 = vec3(a0.xy, h.x);
                        vec3 p1 = vec3(a0.zw, h.y);
                        vec3 p2 = vec3(a1.xy, h.z);
                        vec3 p3 = vec3(a1.zw, h.w);
                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                        p0 *= norm.x;
                        p1 *= norm.y;
                        p2 *= norm.z;
                        p3 *= norm.w;
                        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                    }
                    
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        
                        // Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ· turbulence Î³Î¹Î± ÏÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÎ® ÎµÏ€Î¹Ï†Î¬Î½ÎµÎ¹Î±
                        vec3 noise = vec3(
                            snoise(position * 0.5 + time * 0.1),
                            snoise(position * 0.7 + time * 0.15),
                            snoise(position * 0.9 + time * 0.12)
                        ) * turbulence;
                        
                        vec3 newPosition = position + noise * 0.3;
                        vNormal = normalize(normalMatrix * normalize(newPosition));
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float temperature;
                    uniform float radiationLevel;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec2 vUv;
                    
                    // Blackbody radiation color calculation
                    vec3 blackbodyColor(float temp) {
                        float t = temp / 1000.0;
                        vec3 color;
                        
                        if (t < 3.5) {
                            color = vec3(1.0, 0.2 + t * 0.2, 0.0);
                        } else if (t < 5.0) {
                            color = vec3(1.0, 0.6 + (t - 3.5) * 0.2, 0.1 + (t - 3.5) * 0.3);
                        } else {
                            color = vec3(1.0, 0.8 + (t - 5.0) * 0.1, 0.4 + (t - 5.0) * 0.4);
                        }
                        
                        return color;
                    }
                    
                    float snoise(vec3 v) {
                        // Simplified noise for fragment shader
                        return sin(v.x * 10.0 + time) * sin(v.y * 12.0 + time * 1.1) * sin(v.z * 8.0 + time * 0.9) * 0.5 + 0.5;
                    }
                    
                    void main() {
                        vec3 baseColor = blackbodyColor(temperature);
                        
                        // Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ· granulation patterns
                        float granulation = snoise(vPosition * 5.0 + time * 0.2) * 0.3 + 0.7;
                        
                        // Convection cells
                        float convection = snoise(vPosition * 2.0 + time * 0.1) * 0.2 + 0.8;
                        
                        // Fresnel effect Î³Î¹Î± limb darkening
                        float fresnel = 1.0 - abs(dot(vNormal, vec3(0, 0, 1)));
                        float limbDarkening = 0.3 + 0.7 * pow(1.0 - fresnel, 2.0);
                        
                        vec3 finalColor = baseColor * granulation * convection * limbDarkening * radiationLevel;
                        
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                transparent: false
            });
            
            redGiant = new THREE.Mesh(geometry, material);
            redGiant.position.set(-40, 0, 0);
            redGiant.castShadow = true;
            redGiantGroup.add(redGiant);
            
            // Î ÏÎ¿Î·Î³Î¼Î­Î½Î· Î±Ï„Î¼ÏŒÏƒÏ†Î±Î¹ÏÎ± Î¼Îµ Ï€Î¿Î»Î»Î±Ï€Î»Î¬ ÏƒÏ„ÏÏÎ¼Î±Ï„Î±
            createStellarAtmosphere(redGiant, {
                innerRadius: 8.5,
                outerRadius: 15,
                color: new THREE.Color(0xff4444),
                density: 0.3,
                turbulence: 0.8
            });
            
            // ÎšÎ¿ÏÏÎ½Î± Î¼Îµ ÏÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÎ¬ ÎµÏ†Î­
            createStellarCorona(redGiant, {
                radius: 18,
                color: new THREE.Color(0xff6666),
                intensity: 1.5,
                activity: 0.7
            });
            
            // Î ÏÎ¿Î·Î³Î¼Î­Î½Î¿ Ï†Ï‰Ï„Î¹ÏƒÎ¼ÏŒ
            const redGiantLight = new THREE.PointLight(0xff4444, 3 * stellarRadiationLevel, 150);
            redGiantLight.castShadow = true;
            redGiantLight.shadow.mapSize.width = 2048;
            redGiantLight.shadow.mapSize.height = 2048;
            redGiant.add(redGiantLight);
            
            scene.add(redGiantGroup);
        }
        
        function createStellarAtmosphere(star, params) {
            const atmosphereGeometry = new THREE.SphereGeometry(params.outerRadius, 32, 32);
            const atmosphereMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    innerRadius: { value: params.innerRadius },
                    outerRadius: { value: params.outerRadius },
                    color: { value: params.color },
                    density: { value: params.density },
                    turbulence: { value: params.turbulence }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying float vDistance;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        vDistance = length(position);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float innerRadius;
                    uniform float outerRadius;
                    uniform vec3 color;
                    uniform float density;
                    uniform float turbulence;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying float vDistance;
                    
                    float noise(vec3 p) {
                        return sin(p.x * 0.5 + time * 0.3) * sin(p.y * 0.7 + time * 0.4) * sin(p.z * 0.6 + time * 0.2);
                    }
                    
                    void main() {
                        float normalizedDistance = (vDistance - innerRadius) / (outerRadius - innerRadius);
                        float atmosphericDensity = 1.0 - normalizedDistance;
                        
                        // Atmospheric turbulence
                        float turbulenceEffect = noise(vPosition * 2.0) * turbulence * 0.5 + 0.5;
                        
                        // Fresnel Î³Î¹Î± edge effects
                        float fresnel = 1.0 - abs(dot(vNormal, vec3(0, 0, 1)));
                        
                        float opacity = atmosphericDensity * density * turbulenceEffect * fresnel;
                        
                        gl_FragColor = vec4(color, opacity);
                    }
                `,
                transparent: true,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            star.add(atmosphere);
        }
        
        function createStellarCorona(star, params) {
            const coronaGeometry = new THREE.SphereGeometry(params.radius, 32, 32);
            const coronaMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: params.color },
                    intensity: { value: params.intensity },
                    activity: { value: params.activity }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color;
                    uniform float intensity;
                    uniform float activity;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    float noise(vec3 p) {
                        return sin(p.x * 0.3 + time * 2.0) * sin(p.y * 0.4 + time * 1.8) * sin(p.z * 0.5 + time * 2.2);
                    }
                    
                    void main() {
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 3.0);
                        
                        // Coronal activity
                        float coronalActivity = noise(vPosition * 0.5) * activity * 0.5 + 0.5;
                        
                        // Solar flares simulation
                        float flares = max(0.0, sin(time * 5.0 + vPosition.x * 0.1) * 0.3 + 0.7);
                        
                        float finalIntensity = fresnel * intensity * coronalActivity * flares;
                        
                        gl_FragColor = vec4(color, finalIntensity * 0.4);
                    }
                `,
                transparent: true,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            
            const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
            star.add(corona);
        }
        
        function createUltraRealisticBlueGiant() {
            const blueGiantGroup = new THREE.Group();
            
            // ÎšÏÏÎ¹Î¿ ÏƒÏÎ¼Î± Î¼Îµ ÎµÎ¾Î±Î¹ÏÎµÏ„Î¹ÎºÎ¬ Ï€ÏÎ¿Î·Î³Î¼Î­Î½Î¿ shader
            const geometry = new THREE.SphereGeometry(6, 64, 64);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    temperature: { value: 12100 },
                    radiationLevel: { value: stellarRadiationLevel },
                    stellarActivity: { value: 2.0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec2 vUv;
                    uniform float time;
                    
                    float noise(vec3 p) {
                        return sin(p.x * 8.0 + time * 0.5) * sin(p.y * 6.0 + time * 0.7) * sin(p.z * 10.0 + time * 0.3);
                    }
                    
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        
                        // ÎœÎ¹ÎºÏÏŒÏ„ÎµÏÎ· turbulence Î³Î¹Î± Î¼Ï€Î»Îµ Î³Î¯Î³Î±Î½Ï„Î± (Ï€Î¹Î¿ ÏƒÏ„Î±Î¸ÎµÏÏŒÏ‚)
                        vec3 displacement = normal * noise(position * 2.0) * 0.1;
                        vec3 newPosition = position + displacement;
                        
                        vNormal = normalize(normalMatrix * normalize(newPosition));
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float temperature;
                    uniform float radiationLevel;
                    uniform float stellarActivity;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec2 vUv;
                    
                    vec3 blackbodyColor(float temp) {
                        float t = temp / 1000.0;
                        vec3 color;
                        
                        if (t > 10.0) {
                            // Hot blue stars
                            float blueness = min(1.0, (t - 10.0) / 20.0);
                            color = vec3(0.6 + blueness * 0.2, 0.7 + blueness * 0.2, 1.0);
                        } else {
                            color = vec3(0.8, 0.9, 1.0);
                        }
                        
                        return color;
                    }
                    
                    float noise(vec3 p) {
                        return sin(p.x * 15.0 + time * 2.0) * sin(p.y * 18.0 + time * 1.8) * sin(p.z * 12.0 + time * 2.5) * 0.5 + 0.5;
                    }
                    
                    void main() {
                        vec3 baseColor = blackbodyColor(temperature);
                        
                        // ÎˆÎ½Ï„Î¿Î½Î± UV radiation patterns
                        float uvPattern = noise(vPosition * 8.0) * 0.4 + 0.6;
                        
                        // Stellar pulsations
                        float pulsation = sin(time * 3.0 + vPosition.y * 5.0) * 0.1 + 0.9;
                        
                        // Fresnel Î³Î¹Î± limb brightening (Î±Î½Ï„Î¯Î¸ÎµÏ„Î¿ Î±Ï€ÏŒ ÎºÏŒÎºÎºÎ¹Î½Î¿Ï…Ï‚)
                        float fresnel = abs(dot(vNormal, vec3(0, 0, 1)));
                        float limbBrightening = 0.7 + 0.3 * fresnel;
                        
                        vec3 finalColor = baseColor * uvPattern * pulsation * limbBrightening * radiationLevel * stellarActivity;
                        
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                transparent: false
            });
            
            blueGiant = new THREE.Mesh(geometry, material);
            blueGiant.position.set(40, 0, 0);
            blueGiant.castShadow = true;
            blueGiantGroup.add(blueGiant);
            
            // ÎˆÎ½Ï„Î¿Î½Î· UV Î±ÎºÏ„Î¹Î½Î¿Î²Î¿Î»Î¯Î±
            createUVRadiationField(blueGiant);
            
            // Stellar wind visualization
            createStellarWind(blueGiant, {
                speed: 2000, // km/s
                density: 1.5,
                color: new THREE.Color(0x4488ff)
            });
            
            // Î•Î¾Î±Î¹ÏÎµÏ„Î¹ÎºÎ¬ Î­Î½Ï„Î¿Î½Î¿ Ï†Ï‰Ï‚
            const blueGiantLight = new THREE.PointLight(0x4488ff, 4 * stellarRadiationLevel, 200);
            blueGiantLight.castShadow = true;
            blueGiantLight.shadow.mapSize.width = 2048;
            blueGiantLight.shadow.mapSize.height = 2048;
            blueGiant.add(blueGiantLight);
            
            scene.add(blueGiantGroup);
        }
        
        function createUVRadiationField(star) {
            const uvGeometry = new THREE.SphereGeometry(12, 32, 32);
            const uvMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    intensity: { value: stellarRadiationLevel }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float intensity;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 2.0);
                        float pulse = sin(time * 8.0) * 0.3 + 0.7;
                        
                        // UV radiation visualization
                        vec3 uvColor = vec3(0.3, 0.5, 1.0);
                        float uvIntensity = fresnel * pulse * intensity * 0.6;
                        
                        gl_FragColor = vec4(uvColor, uvIntensity);
                    }
                `,
                transparent: true,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            
            const uvField = new THREE.Mesh(uvGeometry, uvMaterial);
            star.add(uvField);
        }
        
        function createStellarWind(star, params) {
            const particleCount = Math.floor(2000 * particleDensity);
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const ages = new Float32Array(particleCount);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                // Î‘ÏÏ‡Î¹ÎºÎ­Ï‚ Î¸Î­ÏƒÎµÎ¹Ï‚ ÎºÎ¿Î½Ï„Î¬ ÏƒÏ„Î¿Î½ Î±ÏƒÏ„Î­ÏÎ±
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 7 + Math.random() * 2;
                
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
                
                // Î¤Î±Ï‡ÏÏ„Î·Ï„ÎµÏ‚ (Î±ÎºÏ„Î¹Î½Î¹ÎºÎ¬ Ï€ÏÎ¿Ï‚ Ï„Î± Î­Î¾Ï‰)
                const speed = params.speed * 0.001 * (0.8 + Math.random() * 0.4);
                velocities[i * 3] = positions[i * 3] / radius * speed;
                velocities[i * 3 + 1] = positions[i * 3 + 1] / radius * speed;
                velocities[i * 3 + 2] = positions[i * 3 + 2] / radius * speed;
                
                ages[i] = Math.random() * 100;
                sizes[i] = 0.1 + Math.random() * 0.3;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('age', new THREE.BufferAttribute(ages, 1));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: params.color },
                    density: { value: params.density }
                },
                vertexShader: `
                    attribute vec3 velocity;
                    attribute float age;
                    attribute float size;
                    varying float vAge;
                    uniform float time;
                    uniform float density;
                    
                    void main() {
                        vAge = age;
                        vec3 pos = position + velocity * time;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * density * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    varying float vAge;
                    
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5));
                        if (r > 0.5) discard;
                        
                        float alpha = (1.0 - r * 2.0) * (1.0 - vAge * 0.01);
                        gl_FragColor = vec4(color, alpha * 0.6);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const stellarWind = new THREE.Points(geometry, material);
            star.add(stellarWind);
            stellarWinds.push(stellarWind);
        }
        
        function createUltraRealisticWhiteDwarf() {
            const whiteDwarfGroup = new THREE.Group();
            
            // ÎšÏÏÎ¹Î¿ ÏƒÏÎ¼Î± Î¼Îµ ÎºÏÏ…ÏƒÏ„Î±Î»Î»Î¹ÎºÎ® Î´Î¿Î¼Î®
            const geometry = new THREE.SphereGeometry(2, 64, 64);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    temperature: { value: 25200 },
                    crystallization: { value: 0.8 },
                    radiationLevel: { value: stellarRadiationLevel }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec2 vUv;
                    uniform float time;
                    uniform float crystallization;
                    
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        
                        // ÎšÏÏ…ÏƒÏ„Î±Î»Î»Î¹ÎºÎ® Î´Î¿Î¼Î®
                        vec3 crystallinePos = position;
                        float crystal = sin(position.x * 20.0) * sin(position.y * 20.0) * sin(position.z * 20.0);
                        crystallinePos += normal * crystal * crystallization * 0.05;
                        
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(crystallinePos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float temperature;
                    uniform float crystallization;
                    uniform float radiationLevel;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec2 vUv;
                    
                    vec3 whiteDwarfColor(float temp) {
                        // Î Î¿Î»Ï Î¸ÎµÏÎ¼ÏŒ Î»ÎµÏ…ÎºÏŒ Î¼Îµ ÎµÎ»Î±Ï†ÏÎ¬ Î¼Ï€Î»Îµ Î±Ï€ÏŒÏ‡ÏÏ‰ÏƒÎ·
                        float t = temp / 10000.0;
                        return vec3(0.9 + t * 0.1, 0.95 + t * 0.05, 1.0);
                    }
                    
                    void main() {
                        vec3 baseColor = whiteDwarfColor(temperature);
                        
                        // ÎšÏÏ…ÏƒÏ„Î±Î»Î»Î¹ÎºÎ¬ patterns
                        float crystal = sin(vPosition.x * 30.0) * sin(vPosition.y * 30.0) * sin(vPosition.z * 30.0);
                        float crystallineEffect = crystal * crystallization * 0.3 + 0.7;
                        
                        // Degenerate matter effects
                        float degeneracy = sin(time * 10.0 + vPosition.x * 50.0) * 0.1 + 0.9;
                        
                        // Fresnel Î³Î¹Î± metallic look
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 0.5);
                        float metallic = 0.8 + 0.2 * fresnel;
                        
                        vec3 finalColor = baseColor * crystallineEffect * degeneracy * metallic * radiationLevel;
                        
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                transparent: false
            });
            
            whiteDwarf = new THREE.Mesh(geometry, material);
            whiteDwarf.position.set(0, 30, 0);
            whiteDwarf.castShadow = true;
            whiteDwarfGroup.add(whiteDwarf);
            
            // ÎšÏÏ…ÏƒÏ„Î±Î»Î»Î¹ÎºÎ® ÎµÎ¾Ï‰Ï„ÎµÏÎ¹ÎºÎ® Î´Î¿Î¼Î®
            createCrystallineStructure(whiteDwarf);
            
            // Degenerate matter effects
            createDegenerateMatterField(whiteDwarf);
            
                       // ÎˆÎ½Ï„Î¿Î½Î¿ Î»ÎµÏ…ÎºÏŒ Ï†Ï‰Ï‚
            const whiteDwarfLight = new THREE.PointLight(0xffffff, 2.5 * stellarRadiationLevel, 100);
            whiteDwarfLight.castShadow = true;
            whiteDwarfLight.shadow.mapSize.width = 1024;
            whiteDwarfLight.shadow.mapSize.height = 1024;
            whiteDwarf.add(whiteDwarfLight);
            
            scene.add(whiteDwarfGroup);
        }
        
        function createCrystallineStructure(star) {
            const crystalGeometry = new THREE.IcosahedronGeometry(2.3, 3);
            const crystalMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: 0.4 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    uniform float time;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        
                        // Subtle rotation for crystalline effect
                        vec3 rotatedPos = position;
                        rotatedPos.x = position.x * cos(time * 0.1) - position.z * sin(time * 0.1);
                        rotatedPos.z = position.x * sin(time * 0.1) + position.z * cos(time * 0.1);
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(rotatedPos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 2.0);
                        vec3 crystalColor = vec3(0.8, 0.9, 1.0);
                        
                        // Prismatic effect
                        float prism = sin(vPosition.x * 10.0 + time) * sin(vPosition.y * 12.0 + time) * 0.2 + 0.8;
                        
                        gl_FragColor = vec4(crystalColor * prism, fresnel * opacity);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
            star.add(crystal);
        }
        
        function createDegenerateMatterField(star) {
            const fieldGeometry = new THREE.SphereGeometry(3, 32, 32);
            const fieldMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    density: { value: 2.0 }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float density;
                    varying vec3 vPosition;
                    
                    void main() {
                        // Quantum fluctuations
                        float quantum = sin(vPosition.x * 100.0 + time * 20.0) * 
                                      sin(vPosition.y * 80.0 + time * 15.0) * 
                                      sin(vPosition.z * 120.0 + time * 25.0);
                        
                        float intensity = abs(quantum) * density * 0.1;
                        vec3 quantumColor = vec3(0.9, 0.95, 1.0);
                        
                        gl_FragColor = vec4(quantumColor, intensity);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
            star.add(field);
        }
        
        function createUltraRealisticBlackHole() {
            const blackHoleGroup = new THREE.Group();
            
            // Event Horizon Î¼Îµ Schwarzschild radius
            const horizonGeometry = new THREE.SphereGeometry(4, 64, 64);
            const horizonMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    mass: { value: 21.2 } // Solar masses
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float mass;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        // Absolute black with subtle Hawking radiation
                        float hawkingRadiation = sin(time * 50.0 + vPosition.x * 1000.0) * 
                                               sin(time * 60.0 + vPosition.y * 1200.0) * 
                                               sin(time * 40.0 + vPosition.z * 800.0);
                        
                        float radiation = abs(hawkingRadiation) * 0.001; // Extremely weak
                        vec3 hawkingColor = vec3(0.1, 0.05, 0.2);
                        
                        gl_FragColor = vec4(hawkingColor * radiation, 1.0);
                    }
                `,
                transparent: false
            });
            
            blackHole = new THREE.Mesh(horizonGeometry, horizonMaterial);
            blackHole.position.set(0, -30, 0);
            blackHoleGroup.add(blackHole);
            
            // Photon Sphere Î¼Îµ realistic light bending
            createPhotonSphere(blackHole);
            
            // Gravitational lensing effect
            createGravitationalLensing(blackHole);
            
            // Ergosphere Î³Î¹Î± rotating black hole
            createErgosphere(blackHole);
            
            scene.add(blackHoleGroup);
        }
        
        function createPhotonSphere(blackHole) {
            const photonGeometry = new THREE.RingGeometry(6, 6.5, 64);
            const photonMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    rotationSpeed: { value: 0.99 } // Near light speed
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float rotationSpeed;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    void main() {
                        float angle = atan(vUv.y - 0.5, vUv.x - 0.5);
                        
                        // Relativistic beaming effect
                        float beaming = sin(angle * 12.0 + time * 15.0 * rotationSpeed) * 0.5 + 0.5;
                        
                        // Doppler shift simulation
                        float doppler = sin(angle + time * 10.0) * 0.3 + 0.7;
                        vec3 photonColor = vec3(1.0 * doppler, 0.8 * doppler, 0.4 * beaming);
                        
                        float intensity = beaming * 0.8;
                        gl_FragColor = vec4(photonColor, intensity);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            
            const photonSphere = new THREE.Mesh(photonGeometry, photonMaterial);
            photonSphere.rotation.x = Math.PI / 2;
            blackHole.add(photonSphere);
        }
        
        function createGravitationalLensing(blackHole) {
            const lensingGeometry = new THREE.SphereGeometry(8, 32, 32);
            const lensingMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    mass: { value: 21.2 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float mass;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        // Gravitational lensing distortion
                        float lensing = 1.0 / (1.0 + length(vPosition) * 0.1);
                        
                        // Space-time curvature visualization
                        float curvature = sin(length(vPosition) * 2.0 - time * 5.0) * lensing;
                        
                        vec3 lensingColor = vec3(0.2, 0.1, 0.4);
                        float intensity = abs(curvature) * 0.3;
                        
                        gl_FragColor = vec4(lensingColor, intensity);
                    }
                `,
                transparent: true,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            
            const lensing = new THREE.Mesh(lensingGeometry, lensingMaterial);
            blackHole.add(lensing);
        }
        
        function createErgosphere(blackHole) {
            const ergoGeometry = new THREE.SphereGeometry(5.5, 32, 32);
            const ergoMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    angularMomentum: { value: 0.8 }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    uniform float time;
                    uniform float angularMomentum;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normalize(normalMatrix * normal);
                        
                        // Frame dragging effect
                        vec3 draggedPos = position;
                        float drag = angularMomentum * time * 0.1;
                        draggedPos.x = position.x * cos(drag) - position.z * sin(drag);
                        draggedPos.z = position.x * sin(drag) + position.z * cos(drag);
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(draggedPos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float angularMomentum;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        // Frame dragging visualization
                        float dragging = sin(atan(vPosition.z, vPosition.x) * 4.0 + time * 2.0) * 0.5 + 0.5;
                        
                        vec3 ergoColor = vec3(0.5, 0.2, 0.8);
                        float intensity = dragging * angularMomentum * 0.2;
                        
                        gl_FragColor = vec4(ergoColor, intensity);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const ergosphere = new THREE.Mesh(ergoGeometry, ergoMaterial);
            blackHole.add(ergosphere);
        }
        
        function createAdvancedAccretionDisk() {
            const diskGeometry = new THREE.RingGeometry(8, 25, 128, 32);
            const diskMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    innerRadius: { value: 8 },
                    outerRadius: { value: 25 },
                    temperature: { value: 1.0 },
                    viscosity: { value: 0.1 },
                    magneticField: { value: 1.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying float vRadius;
                    varying vec3 vPosition;
                    
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        vRadius = length(position.xy);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float innerRadius;
                    uniform float outerRadius;
                    uniform float temperature;
                    uniform float viscosity;
                    uniform float magneticField;
                    varying vec2 vUv;
                    varying float vRadius;
                    varying vec3 vPosition;
                    
                    vec3 blackbodyFromRadius(float r) {
                        // Temperature decreases with radius (T âˆ r^-3/4)
                        float temp = pow(innerRadius / r, 0.75) * 10000.0;
                        
                        if (temp > 20000.0) {
                            return vec3(0.7, 0.8, 1.0); // Blue-white (very hot)
                        } else if (temp > 10000.0) {
                            return vec3(1.0, 0.9, 0.8); // White
                        } else if (temp > 5000.0) {
                            return vec3(1.0, 0.8, 0.6); // Yellow
                        } else {
                            return vec3(1.0, 0.5, 0.2); // Orange-red
                        }
                    }
                    
                    float turbulence(vec3 p) {
                        return sin(p.x * 2.0 + time * 0.5) * 
                               sin(p.y * 3.0 + time * 0.7) * 
                               sin(p.z * 1.5 + time * 0.3);
                    }
                    
                    void main() {
                        float normalizedRadius = (vRadius - innerRadius) / (outerRadius - innerRadius);
                        
                        // Keplerian velocity (v âˆ r^-1/2)
                        float keplerianVelocity = 1.0 / sqrt(vRadius / innerRadius);
                        float angle = atan(vPosition.y, vPosition.x);
                        
                        // Spiral density waves
                        float spiral = sin(angle * 3.0 - time * keplerianVelocity * 2.0 + vRadius * 0.2) * 0.5 + 0.5;
                        
                        // Magnetorotational instability
                        float mri = turbulence(vPosition * 5.0) * magneticField * 0.3 + 0.7;
                        
                        // Viscous heating
                        float heating = viscosity * keplerianVelocity * (1.0 - normalizedRadius);
                        
                        vec3 diskColor = blackbodyFromRadius(vRadius);
                        float intensity = spiral * mri * heating * temperature;
                        
                        // Inner edge brightening
                        if (normalizedRadius < 0.1) {
                            intensity *= 3.0;
                            diskColor = vec3(1.0, 0.9, 0.8);
                        }
                        
                        // Opacity falloff
                        float opacity = (1.0 - normalizedRadius) * intensity * 0.8;
                        
                        gl_FragColor = vec4(diskColor, opacity);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            
            accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
            accretionDisk.position.copy(blackHole.position);
            accretionDisk.rotation.x = Math.PI / 2;
            scene.add(accretionDisk);
        }
        
        function createStellarWindSystems() {
            // Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Î±ÏƒÏ„ÏÎ¹ÎºÏÎ½ Î±Î½Î­Î¼Ï‰Î½ Î³Î¹Î± ÏŒÎ»Î± Ï„Î± Î±ÏƒÏ„Î­ÏÎ¹Î±
            [redGiant, blueGiant].forEach(star => {
                if (star) {
                    const windParams = star === redGiant ? 
                        { speed: 30, density: 2.0, color: new THREE.Color(0xff6666) } :
                        { speed: 2000, density: 1.0, color: new THREE.Color(0x6666ff) };
                    
                    createAdvancedStellarWind(star, windParams);
                }
            });
        }
        
        function createAdvancedStellarWind(star, params) {
            const particleCount = Math.floor(3000 * particleDensity * effectsQuality / 3);
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const ages = new Float32Array(particleCount);
            const temperatures = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                // Î˜Î­ÏƒÎµÎ¹Ï‚ Î¼Îµ ÏƒÏ†Î±Î¹ÏÎ¹ÎºÎ® ÎºÎ±Ï„Î±Î½Î¿Î¼Î®
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = (star === redGiant ? 9 : 7) + Math.random() * 3;
                
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
                
                // Î¤Î±Ï‡ÏÏ„Î·Ï„ÎµÏ‚ Î¼Îµ realistic values
                const speed = params.speed * 0.0001 * (0.5 + Math.random());
                const direction = new THREE.Vector3(
                    positions[i * 3],
                    positions[i * 3 + 1],
                    positions[i * 3 + 2]
                ).normalize();
                
                velocities[i * 3] = direction.x * speed;
                velocities[i * 3 + 1] = direction.y * speed;
                velocities[i * 3 + 2] = direction.z * speed;
                
                ages[i] = Math.random() * 200;
                temperatures[i] = 1000 + Math.random() * 5000;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('age', new THREE.BufferAttribute(ages, 1));
            geometry.setAttribute('temperature', new THREE.BufferAttribute(temperatures, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: params.color },
                    density: { value: params.density },
                    thermalLevel: { value: thermalRadiation }
                },
                vertexShader: `
                    attribute vec3 velocity;
                    attribute float age;
                    attribute float temperature;
                    varying float vAge;
                    varying float vTemperature;
                    uniform float time;
                    uniform float density;
                    
                    void main() {
                        vAge = age;
                        vTemperature = temperature;
                        
                        vec3 pos = position + velocity * time;
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        
                        float size = (temperature / 3000.0) * density * (500.0 / -mvPosition.z);
                        gl_PointSize = max(size, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float thermalLevel;
                    varying float vAge;
                    varying float vTemperature;
                    
                    vec3 temperatureColor(float temp) {
                        if (temp < 2000.0) {
                            return vec3(1.0, 0.3, 0.1);
                        } else if (temp < 4000.0) {
                            return vec3(1.0, 0.7, 0.3);
                        } else {
                            return vec3(0.9, 0.9, 1.0);
                        }
                    }
                    
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5));
                        if (r > 0.5) discard;
                        
                        vec3 thermalColor = temperatureColor(vTemperature);
                        vec3 finalColor = mix(color.rgb, thermalColor, thermalLevel * 0.5);
                        
                        float alpha = (1.0 - r * 2.0) * (1.0 - vAge * 0.005) * 0.7;
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const wind = new THREE.Points(geometry, material);
            star.add(wind);
            stellarWinds.push(wind);
        }
        
        function createMagneticFieldSystems() {
            [redGiant, blueGiant, whiteDwarf].forEach(star => {
                if (star) {
                    createMagneticFieldLines(star);
                }
            });
        }
        
        function createMagneticFieldLines(star) {
            const fieldStrength = star === blueGiant ? 1000 : (star === whiteDwarf ? 10000 : 100); // Gauss
            const lineCount = Math.floor(16 * effectsQuality / 3);
            
            for (let i = 0; i < lineCount; i++) {
                const angle = (i / lineCount) * Math.PI * 2;
                const fieldLine = createSingleMagneticFieldLine(star, angle, fieldStrength);
                magneticFieldLines.push(fieldLine);
                star.add(fieldLine);
            }
        }
        
        function createSingleMagneticFieldLine(star, angle, strength) {
            const points = [];
            const radius = star === whiteDwarf ? 3 : (star === redGiant ? 10 : 8);
            
            // Dipole field lines
            for (let t = 0; t <= Math.PI; t += 0.05) {
                const r = radius * Math.sin(t) * Math.sin(t);
                const x = r * Math.cos(angle);
                const y = radius * Math.cos(t);
                const z = r * Math.sin(angle);
                points.push(new THREE.Vector3(x, y, z));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    strength: { value: strength },
                    color: { value: new THREE.Color(star === redGiant ? 0xff00ff : 
                                                   star === blueGiant ? 0x00ffff : 0xffff00) }
                },
                vertexShader: `
                    varying float vPosition;
                    uniform float time;
                    
                    void main() {
                        vPosition = position.y;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float strength;
                    uniform vec3 color;
                    varying float vPosition;
                    
                    void main() {
                        float pulse = sin(time * 3.0 + vPosition * 0.1) * 0.3 + 0.7;
                        float intensity = (strength / 1000.0) * pulse * 0.6;
                        
                        gl_FragColor = vec4(color, intensity);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            return new THREE.Line(geometry, material);
        }
        
        function createAdvancedNebulae() {
            // Planetary nebula Î³ÏÏÏ‰ Î±Ï€ÏŒ Ï„Î¿Î½ Î»ÎµÏ…ÎºÏŒ Î½Î¬Î½Î¿
            createPlanetaryNebula(whiteDwarf);
            
            // Supernova remnant
            createSupernovaRemnant();
        }
        
        function createPlanetaryNebula(star) {
            const nebulaGeometry = new THREE.SphereGeometry(15, 32, 32);
            const nebulaMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    expansion: { value: 1.0 },
                    ionization: { value: 0.8 }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    uniform float time;
                    uniform float expansion;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        
                        // Expanding nebula
                        vec3 expandedPos = position * (1.0 + expansion * time * 0.01);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(expandedPos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float ionization;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    float noise(vec3 p) {
                        return sin(p.x * 0.5 + time * 0.2) * sin(p.y * 0.7 + time * 0.3) * sin(p.z * 0.6 + time * 0.25);
                    }
                    
                    void main() {
                        float density = noise(vPosition * 2.0) * 0.5 + 0.5;
                        
                        // Ionization zones
                        float distance = length(vPosition);
                        float ionizationLevel = ionization * (20.0 / distance);
                        
                        // Different emission lines
                        vec3 hAlpha = vec3(1.0, 0.2, 0.2); // Hydrogen alpha
                        vec3 oiii = vec3(0.2, 1.0, 0.3);   // Oxygen III
                        vec3 heii = vec3(0.3, 0.3, 1.0);   // Helium II
                        
                        vec3 nebulaColor = mix(mix(hAlpha, oiii, ionizationLevel), heii, ionizationLevel * 0.5);
                        
                        float fresnel = 1.0 - abs(dot(vNormal, vec3(0, 0, 1)));
                        float opacity = density * fresnel * 0.15;
                        
                        gl_FragColor = vec4(nebulaColor, opacity);
                    }
                `,
                transparent: true,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            
            const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
            nebula.position.copy(star.position);
            scene.add(nebula);
        }
        
        function createSupernovaRemnant() {
            const remnantGeometry = new THREE.SphereGeometry(35, 32, 32);
            const remnantMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    shockwave: { value: 1.0 }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float shockwave;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    float noise(vec3 p) {
                        return sin(p.x * 0.1 + time * 0.5) * sin(p.y * 0.15 + time * 0.3) * sin(p.z * 0.12 + time * 0.4);
                    }
                    
                    void main() {
                        float distance = length(vPosition);
                        float shockFront = abs(sin(distance * 0.1 - time * 2.0)) * shockwave;
                        
                        vec3 shockColor = vec3(1.0, 0.4, 0.1);
                        float turbulence = noise(vPosition) * 0.5 + 0.5;
                        
                        float fresnel = 1.0 - abs(dot(vNormal, vec3(0, 0, 1)));
                        float opacity = shockFront * turbulence * fresnel * 0.1;
                        
                        gl_FragColor = vec4(shockColor, opacity);
                    }
                `,
                transparent: true,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            
            const remnant = new THREE.Mesh(remnantGeometry, remnantMaterial);
            remnant.position.set(60, 0, -40);
            scene.add(remnant);
        }
        
        function setupEventListeners() {
            // Î§ÎµÎ¹ÏÎ¹ÏƒÎ¼ÏŒÏ‚ Ï€Î¿Î½Ï„Î¹ÎºÎ¹Î¿Ï
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            
            // Î§ÎµÎ¹ÏÎ¹ÏƒÎ¼ÏŒÏ‚ Î±Ï†Î®Ï‚
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onTouchEnd);
            
            // Î§ÎµÎ¹ÏÎ¹ÏƒÎ¼ÏŒÏ‚ Ï€Î±ÏÎ±Î¸ÏÏÎ¿Ï…
            window.addEventListener('resize', onWindowResize);
            
            // Controls Î¼Îµ Î²ÎµÎ»Ï„Î¹Ï‰Î¼Î­Î½Î· Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒÏ„Î·Ï„Î±
            setupAdvancedControls();
            
            // Î Î»Î·ÎºÏ„ÏÎ¿Î»ÏŒÎ³Î¹Î¿
            document.addEventListener('keydown', onKeyDown);
        }
        
        function setupAdvancedControls() {
            document.getElementById('timeSpeed').addEventListener('input', function(e) {
                timeSpeed = parseFloat(e.target.value);
                document.getElementById('timeValue').textContent = timeSpeed.toFixed(1) + 'x';
            });
            
            document.getElementById('gravityField').addEventListener('input', function(e) {
                gravityFieldStrength = parseFloat(e.target.value);
                document.getElementById('gravityValue').textContent = gravityFieldStrength.toFixed(1);
                updateGravityEffects();
            });
            
            document.getElementById('stellarRadiation').addEventListener('input', function(e) {
                stellarRadiationLevel = parseFloat(e.target.value);
                document.getElementById('radiationValue').textContent = stellarRadiationLevel.toFixed(1);
                updateRadiationEffects();
            });
            
            document.getElementById('effectsQuality').addEventListener('input', function(e) {
                effectsQuality = parseInt(e.target.value);
                const qualityNames = ['Î§Î±Î¼Î·Î»Î®', 'ÎœÎ­Ï„ÏÎ¹Î±', 'ÎšÎ±Î»Î®', 'Î¥ÏˆÎ·Î»Î®', 'Î•Î¾Î±Î¹ÏÎµÏ„Î¹ÎºÎ®'];
                document.getElementById('qualityValue').textContent = qualityNames[effectsQuality - 1];
                document.getElementById('currentQuality').textContent = qualityNames[effectsQuality - 1];
                updateEffectsQuality();
            });
            
            document.getElementById('particleDensity').addEventListener('input', function(e) {
                particleDensity = parseFloat(e.target.value);
                document.getElementById('particleValue').textContent = particleDensity.toFixed(1);
                updateParticleSystems();
            });
            
            document.getElementById('thermalRadiation').addEventListener('input', function(e) {
                thermalRadiation = parseFloat(e.target.value);
                document.getElementById('thermalValue').textContent = thermalRadiation.toFixed(1);
                updateThermalEffects();
            });
        }
        
        function updateGravityEffects() {
            // Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎ· Î²Î±ÏÏ…Ï„Î¹ÎºÏÎ½ ÎµÏ†Î­
            if (accretionDisk && accretionDisk.material.uniforms) {
                accretionDisk.material.uniforms.viscosity.value = 0.1 * gravityFieldStrength;
            }
        }
        
        function updateRadiationEffects() {
            // Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎ· ÏŒÎ»Ï‰Î½ Ï„Ï‰Î½ stellar materials
            [redGiant, blueGiant, whiteDwarf].forEach(star => {
                if (star && star.material && star.material.uniforms) {
                    star.material.uniforms.radiationLevel.value = stellarRadiationLevel;
                }
            });
        }
        
        function updateEffectsQuality() {
            // Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎ· Ï€Î¿Î¹ÏŒÏ„Î·Ï„Î±Ï‚ ÎµÏ†Î­ (Î¸Î± Ï‡ÏÎµÎ¹Î±ÏƒÏ„ÎµÎ¯ restart Î³Î¹Î± Ï€Î»Î®ÏÎ· ÎµÏ†Î±ÏÎ¼Î¿Î³Î®)
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, effectsQuality / 2));
        }
        
        function updateParticleSystems() {
            // Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎ· Ï€Ï…ÎºÎ½ÏŒÏ„Î·Ï„Î±Ï‚ ÏƒÏ‰Î¼Î±Ï„Î¹Î´Î¯Ï‰Î½
            stellarWinds.forEach(wind => {
                if (wind.material && wind.material.uniforms) {
                    wind.material.uniforms.density.value = particleDensity;
                }
            });
        }
        
        function updateThermalEffects() {
            // Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎ· Î¸ÎµÏÎ¼Î¹ÎºÏÎ½ ÎµÏ†Î­
            stellarWinds.forEach(wind => {
                if (wind.material && wind.material.uniforms) {
                    wind.material.uniforms.thermalLevel.value = thermalRadiation;
                }
            });
        }
        
        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            cameraAngleY += deltaX * 0.008;
            cameraAngleX += deltaY * 0.008;
            
            cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngleX));
            
            updateCameraPosition();
            
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onMouseUp() {
            isMouseDown = false;
        }
        
        function onMouseWheel(event) {
            cameraDistance += event.deltaY * 0.05;
            cameraDistance = Math.max(10, Math.min(300, cameraDistance));
            updateCameraPosition();
        }
        
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
                isMouseDown = true;
            }
        }
        
        function onTouchMove(event) {
            if (event.touches.length === 1 && isMouseDown) {
                const deltaX = event.touches[0].clientX - mouseX;
                const deltaY = event.touches[0].clientY - mouseY;
                
                cameraAngleY += deltaX * 0.008;
                cameraAngleX += deltaY * 0.008;
                
                cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngleX));
                
                updateCameraPosition();
                
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
            }
            event.preventDefault();
        }
        
        function onTouchEnd() {
            isMouseDown = false;
        }
        
        function onKeyDown(event) {
            switch(event.code) {
                case 'Space':
                    toggleAnimation();
                    event.preventDefault();
                    break;
                case 'KeyF':
                    toggleFullscreen();
                    break;
                case 'Digit1':
                    focusRedGiant();
                    break;
                case 'Digit2':
                    focusBlueGiant();
                    break;
                case 'Digit3':
                    focusWhiteDwarf();
                    break;
                case 'Digit4':
                    focusBlackHole();
                    break;
                case 'KeyQ':
                    effectsQuality = Math.min(5, effectsQuality + 1);
                    updateEffectsQuality();
                    break;
                case 'KeyW':
                    effectsQuality = Math.max(1, effectsQuality - 1);
                    updateEffectsQuality();
                    break;
            }
        }
        
        function updateCameraPosition() {
            const x = cameraDistance * Math.sin(cameraAngleY) * Math.cos(cameraAngleX);
            const y = cameraDistance * Math.sin(cameraAngleX);
            const z = cameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
            
            camera.position.set(
                cameraTarget.x + x,
                cameraTarget.y + y,
                cameraTarget.z + z
            );
            camera.lookAt(cameraTarget);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            if (isAnimating) {
                animationId = requestAnimationFrame(animate);
                
                const time = Date.now() * 0.001;
                
                // Performance monitoring
                frameCount++;
                const currentTime = performance.now();
                if (currentTime - lastTime >= 1000) {
                    fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                    document.getElementById('fpsCounter').textContent = fps;
                    frameCount = 0;
                    lastTime = currentTime;
                }
                
                // Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎ· ÏŒÎ»Ï‰Î½ Ï„Ï‰Î½ shader uniforms
                updateShaderUniforms(time);
                
                // Î ÎµÏÎ¹ÏƒÏ„ÏÎ¿Ï†Î® Î±ÏƒÏ„Î­ÏÏ‰Î½
                updateStellarRotations(time);
                
                // Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎ· particle systems
                updateParticleSystemsAnimation(time);
                
                // Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎ· Î¼Î±Î³Î½Î·Ï„Î¹ÎºÏÎ½ Ï€ÎµÎ´Î¯Ï‰Î½
                updateMagneticFields(time);
                
                // Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎ· Î´Î¯ÏƒÎºÎ¿Ï… Ï€ÏÎ¿ÏƒÎ±ÏÎ¾Î·ÏƒÎ·Ï‚
                updateAccretionDisk(time);
            }
            
            renderer.render(scene, camera);
            
            if (!isAnimating) {
                animationId = requestAnimationFrame(animate);
            }
        }
        
        function updateShaderUniforms(time) {
            // Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎ· ÏŒÎ»Ï‰Î½ Ï„Ï‰Î½ shader uniforms
            scene.traverse((object) => {
                if (object.material && object.material.uniforms) {
                    if (object.material.uniforms.time) {
                        object.material.uniforms.time.value = time * timeSpeed;
                    }
                }
            });
        }
        
        function updateStellarRotations(time) {
            if (redGiant) {
                redGiant.rotation.y += 0.003 * timeSpeed;
            }
            
            if (blueGiant) {
                blueGiant.rotation.y += 0.008 * timeSpeed;
            }
            
            if (whiteDwarf) {
                whiteDwarf.rotation.y += 0.015 * timeSpeed;
                // Precession
                whiteDwarf.rotation.x = Math.sin(time * 0.1) * 0.1;
            }
            
            if (blackHole) {
                // Frame dragging effect
                blackHole.rotation.y += 0.02 * timeSpeed;
            }
        }
        
        function updateParticleSystemsAnimation(time) {
            stellarWinds.forEach((wind, index) => {
                if (wind.geometry && wind.geometry.attributes.position) {
                    const positions = wind.geometry.attributes.position.array;
                    const velocities = wind.geometry.attributes.velocity.array;
                    const ages = wind.geometry.attributes.age.array;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        // Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎ· Î¸Î­ÏƒÎµÏ‰Î½
                        positions[i] += velocities[i] * timeSpeed;
                        positions[i + 1] += velocities[i + 1] * timeSpeed;
                        positions[i + 2] += velocities[i + 2] * timeSpeed;
                        
                        // Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎ· Î·Î»Î¹ÎºÎ¹ÏÎ½
                        ages[i / 3] += timeSpeed;
                        
                        // Reset particles Ï€Î¿Ï… Î­Ï‡Î¿Ï…Î½ Ï†ÏÎ³ÎµÎ¹ Ï€Î¿Î»Ï Î¼Î±ÎºÏÎ¹Î¬
                        const distance = Math.sqrt(
                            positions[i] * positions[i] +
                            positions[i + 1] * positions[i + 1] +
                            positions[i + 2] * positions[i + 2]
                        );
                        
                        if (distance > 100 || ages[i / 3] > 300) {
                            // Reset particle
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.acos(2 * Math.random() - 1);
                            const radius = 8 + Math.random() * 2;
                            
                            positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                            positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
                            positions[i + 2] = radius * Math.cos(phi);
                            
                            ages[i / 3] = 0;
                        }
                    }
                    
                    wind.geometry.attributes.position.needsUpdate = true;
                    wind.geometry.attributes.age.needsUpdate = true;
                }
            });
        }
        
        function updateMagneticFields(time) {
            magneticFieldLines.forEach(line => {
                if (line.material && line.material.uniforms) {
                    line.material.uniforms.time.value = time * timeSpeed;
                }
            });
        }
        
        function updateAccretionDisk(time) {
            if (accretionDisk) {
                accretionDisk.rotation.z += 0.01 * timeSpeed;
                
                if (accretionDisk.material.uniforms) {
                    accretionDisk.material.uniforms.time.value = time * timeSpeed;
                    accretionDisk.material.uniforms.temperature.value = stellarRadiationLevel;
                    accretionDisk.material.uniforms.magneticField.value = gravityFieldStrength;
                }
            }
        }
        
        function focusRedGiant() {
            cameraTarget.copy(redGiant.position);
            cameraDistance = 35;
            updateCameraPosition();
            updateStellarInfo('redGiant');
            currentFocus = 'redGiant';
        }
        
        function focusBlueGiant() {
            cameraTarget.copy(blueGiant.position);
            cameraDistance = 30;
            updateCameraPosition();
            updateStellarInfo('blueGiant');
            currentFocus = 'blueGiant';
        }
        
        function focusWhiteDwarf() {
            cameraTarget.copy(whiteDwarf.position);
            cameraDistance = 20;
            updateCameraPosition();
            updateStellarInfo('whiteDwarf');
            currentFocus = 'whiteDwarf';
        }
        
        function focusBlackHole() {
            cameraTarget.copy(blackHole.position);
            cameraDistance = 40;
            updateCameraPosition();
            updateStellarInfo('blackHole');
            currentFocus = 'blackHole';
        }
        
        function updateStellarInfo(objectType) {
            const data = stellarData[objectType];
            document.getElementById('objectName').textContent = data.name;
            document.getElementById('objectType').textContent = data.type;
            document.getElementById('objectMass').textContent = data.mass;
            document.getElementById('objectTemp').textContent = data.temp;
            document.getElementById('objectAge').textContent = data.age;
            document.getElementById('objectDistance').textContent = data.distance;
            document.getElementById('objectLuminosity').textContent = data.luminosity;
            document.getElementById('objectMetallicity').textContent = data.metallicity;
        }
        
        function createSupernova() {
            if (!blueGiant) return;
            
            // Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± realistic supernova explosion
            const explosionGeometry = new THREE.SphereGeometry(1, 32, 32);
            const explosionMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    explosionRadius: { value: 1 },
                    shockwaveSpeed: { value: 30000 }, // km/s
                    energy: { value: 1e44 } // ergs
                },
                vertexShader: `
                    uniform float explosionRadius;
                    uniform float time;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        vNormal = normal;
                        vPosition = position;
                        vec3 newPosition = position * explosionRadius;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float energy;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        float intensity = 1.0 - time * 0.05;
                        
                        // Supernova color evolution
                        vec3 color;
                        if (time < 5.0) {
                            color = vec3(1.0, 1.0, 0.8); // Initial flash
                        } else if (time < 15.0) {
                            color = vec3(1.0, 0.8, 0.4); // Cooling
                        } else {
                            color = vec3(1.0, 0.4, 0.2); // Nebular phase
                        }
                        
                        float fresnel = 1.0 - abs(dot(vNormal, vec3(0, 0, 1)));
                        gl_FragColor = vec4(color, intensity * fresnel);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.copy(blueGiant.position);
            scene.add(explosion);
            
            // ÎšÎ¹Î½Î¿ÏÎ¼ÎµÎ½Î· Î­ÎºÏÎ·Î¾Î· Î¼Îµ realistic physics
            let explosionTime = 0;
            const explosionAnimation = () => {
                explosionTime += 0.1;
                explosion.material.uniforms.time.value = explosionTime;
                explosion.material.uniforms.explosionRadius.value = 1 + explosionTime * 2;
                
                if (explosionTime < 50) {
                    requestAnimationFrame(explosionAnimation);
                } else {
                    scene.remove(explosion);
                    // Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± neutron star Î® black hole
                    createSupernovaRemnantObject(blueGiant.position);
                }
            };
            explosionAnimation();
        }
        
        function createSupernovaRemnantObject(position) {
            // 90% Ï€Î¹Î¸Î±Î½ÏŒÏ„Î·Ï„Î± Î³Î¹Î± neutron star, 10% Î³Î¹Î± black hole
            if (Math.random() < 0.9) {
                createNeutronStar(position);
            } else {
                createStellarBlackHole(position);
            }
        }
        
        function createNeutronStar(position) {
            const neutronStarGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const neutronStarMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    magneticField: { value: 1e12 }, // Gauss
                    rotationPeriod: { value: 0.033 } // 33ms
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float magneticField;
                    uniform float rotationPeriod;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        // Neutron star surface
                        float pulse = sin(time / rotationPeriod * 2.0 * 3.14159) * 0.5 + 0.5;
                        vec3 neutronColor = vec3(0.9, 0.9, 1.0);
                        
                        // Magnetic field effects
                        float magnetic = magneticField / 1e12;
                        vec3 magneticGlow = vec3(0.5, 0.8, 1.0) * magnetic * 0.1;
                        
                        gl_FragColor = vec4(neutronColor + magneticGlow, 1.0);
                    }
                `,
                transparent: false
            });
            
            const neutronStar = new THREE.Mesh(neutronStarGeometry, neutronStarMaterial);
            neutronStar.position.copy(position);
            scene.add(neutronStar);
        }
        
        function createStellarBlackHole(position) {
            // Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Î½Î­Î±Ï‚ Î¼Î±ÏÏÎ·Ï‚ Ï„ÏÏÏ€Î±Ï‚
            const newBlackHole = blackHole.clone();
            newBlackHole.position.copy(position);
            scene.add(newBlackHole);
        }
        
        function createGammaRayBurst() {
            if (!blueGiant) return;
            
            // Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± GRB jets
            const jetGeometry = new THREE.CylinderGeometry(0.1, 2, 50, 8);
            const jetMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    energy: { value: 1e54 }, // ergs
                    lorentzFactor: { value: 300 }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    uniform float time;
                    
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float energy;
                    uniform float lorentzFactor;
                    varying vec3 vPosition;
                    
                    void main() {
                        float intensity = energy / 1e54;
                        vec3 gammaColor = vec3(0.8, 0.9, 1.0);
                        
                        // Relativistic beaming
                        float beaming = lorentzFactor / 300.0;
                        float pulse = sin(time * 20.0) * 0.5 + 0.5;
                        
                        gl_FragColor = vec4(gammaColor * intensity * beaming, pulse * 0.8);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            // Î”ÏÎ¿ Î±Î½Ï„Î¯Î¸ÎµÏ„Î± jets
            const jet1 = new THREE.Mesh(jetGeometry, jetMaterial);
            const jet2 = new THREE.Mesh(jetGeometry, jetMaterial);
            
            jet1.position.copy(blueGiant.position);
            jet2.position.copy(blueGiant.position);
            jet2.rotation.z = Math.PI;
            
            scene.add(jet1);
            scene.add(jet2);
            
            // Animation
            setTimeout(() => {
                scene.remove(jet1);
                scene.remove(jet2);
            }, 10000);
        }
        
        function toggleAnimation() {
            isAnimating = !isAnimating;
            if (isAnimating) {
                animate();
            }
        }
        
        function resetView() {
            cameraDistance = 80;
            cameraAngleX = 0;
            cameraAngleY = 0;
            cameraTarget.set(0, 0, 0);
            updateCameraPosition();
            updateStellarInfo('redGiant');
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        function toggleAccretionDisk() {
            showAccretionDisk = !showAccretionDisk;
            if (accretionDisk) {
                accretionDisk.visible = showAccretionDisk;
            }
        }
        
        function toggleStellarWinds() {
            showStellarWinds = !showStellarWinds;
            stellarWinds.forEach(wind => {
                wind.visible = showStellarWinds;
            });
        }
        
        function toggleMagneticFields() {
            showMagneticFields = !showMagneticFields;
            magneticFieldLines.forEach(line => {
                line.visible = showMagneticFields;
            });
        }
        
        function toggleRelativisticEffects() {
            showRelativisticEffects = !showRelativisticEffects;
            // Î•Î½ÎµÏÎ³Î¿Ï€Î¿Î¯Î·ÏƒÎ·/Î±Ï€ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¯Î·ÏƒÎ· ÏƒÏ‡ÎµÏ„Î¹ÎºÎ¹ÏƒÏ„Î¹ÎºÏÎ½ ÎµÏ†Î­
        }
        
        function toggleQuantumEffects() {
            showQuantumEffects = !showQuantumEffects;
            // Î•Î½ÎµÏÎ³Î¿Ï€Î¿Î¯Î·ÏƒÎ·/Î±Ï€ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¯Î·ÏƒÎ· ÎºÎ²Î±Î½Ï„Î¹ÎºÏÎ½ ÎµÏ†Î­
        }
        
        function toggleAdvancedPhysics() {
            advancedPhysics = !advancedPhysics;
            // Î•Î½ÎµÏÎ³Î¿Ï€Î¿Î¯Î·ÏƒÎ· Ï€ÏÎ¿Î·Î³Î¼Î­Î½Î·Ï‚ Ï†Ï…ÏƒÎ¹ÎºÎ®Ï‚ Ï€ÏÎ¿ÏƒÎ¿Î¼Î¿Î¯Ï‰ÏƒÎ·Ï‚
        }
        
        // Î•ÎºÎºÎ¯Î½Î·ÏƒÎ· Ï„Î·Ï‚ ÎµÏ†Î±ÏÎ¼Î¿Î³Î®Ï‚
        init();
    </script>
</body>
</html>
